const SchemaConverter = require('../../utils/schemaConverter');
const { UNIVERSAL_TYPES, SCHEMA_FORMATS } = require('../../constants/schemaTypes');

describe('SchemaConverter Utility Tests', () => {
  describe('Schema Conversion', () => {
    it('should convert schema between database types', () => {
      const sourceSchema = {
        columns: [
          { name: 'id', dataType: 'int' },
          { name: 'name', dataType: 'varchar' },
          { name: 'created', dataType: 'datetime' }
        ]
      };

      const converted = SchemaConverter.convertSchema(sourceSchema, 'mysql', 'postgresql');
      
      expect(converted.columns).toHaveLength(3);
      expect(converted.columns[0].dataType).toEqual('integer');
      expect(converted.columns[1].dataType).toEqual('character varying');
      expect(converted.columns[2].dataType).toEqual('timestamp');
      expect(converted.sourceDbType).toEqual('mysql');
      expect(converted.targetDbType).toEqual('postgresql');
    });

    it('should preserve original type information', () => {
      const sourceSchema = {
        columns: [
          { name: 'amount', dataType: 'decimal' }
        ]
      };

      const converted = SchemaConverter.convertSchema(sourceSchema, 'mysql', 'postgresql');
      
      expect(converted.columns[0].originalType).toEqual('decimal');
      expect(converted.columns[0].universalType).toEqual(UNIVERSAL_TYPES.DECIMAL);
    });
  });

  describe('Schema Compatibility', () => {
    it('should validate schema compatibility', () => {
      const sourceSchema = {
        columns: [
          { name: 'user_id', dataType: 'INTEGER', universalType: UNIVERSAL_TYPES.INTEGER },
          { name: 'user_name', dataType: 'VARCHAR', universalType: UNIVERSAL_TYPES.STRING }
        ]
      };

      const targetSchema = {
        columns: [
          { name: 'id', dataType: 'BIGINT', universalType: UNIVERSAL_TYPES.LONG },
          { name: 'name', dataType: 'TEXT', universalType: UNIVERSAL_TYPES.TEXT }
        ]
      };

      const result = SchemaConverter.validateSchemaCompatibility(sourceSchema, targetSchema);
      
      expect(result.isCompatible).toBe(true);
      expect(result.mappingSuggestions).toHaveLength(2);
      expect(result.compatibilityScore).toBeGreaterThan(0);
    });

    it('should detect incompatible schemas', () => {
      const sourceSchema = {
        columns: [
          { name: 'data', dataType: 'BLOB', universalType: UNIVERSAL_TYPES.BINARY }
        ]
      };

      const targetSchema = {
        columns: [
          { name: 'value', dataType: 'INTEGER', universalType: UNIVERSAL_TYPES.INTEGER }
        ]
      };

      const result = SchemaConverter.validateSchemaCompatibility(sourceSchema, targetSchema);
      
      expect(result.issues.length).toBeGreaterThan(0);
      expect(result.issues[0].type).toEqual('NO_COMPATIBLE_TARGET');
    });
  });

  describe('Auto Mapping', () => {
    it('should generate automatic mapping rules for matching columns', () => {
      const sourceSchema = {
        columns: [
          { name: 'user_id', dataType: 'INTEGER', universalType: UNIVERSAL_TYPES.INTEGER },
          { name: 'user_name', dataType: 'VARCHAR', universalType: UNIVERSAL_TYPES.STRING }
        ]
      };

      const targetSchema = {
        columns: [
          { name: 'user_id', dataType: 'INTEGER', universalType: UNIVERSAL_TYPES.INTEGER },
          { name: 'user_name', dataType: 'VARCHAR', universalType: UNIVERSAL_TYPES.STRING }
        ]
      };

      const mappingRules = SchemaConverter.generateAutoMapping(sourceSchema, targetSchema);
      
      expect(mappingRules).toHaveLength(2);
      expect(mappingRules[0].transformationType).toEqual('direct');
      expect(mappingRules[0].confidence).toEqual(1.0);
      expect(mappingRules[0].isAutoGenerated).toBe(true);
    });

    it('should handle type conversions in mapping rules', () => {
      const sourceSchema = {
        columns: [
          { name: 'age', dataType: 'VARCHAR', universalType: UNIVERSAL_TYPES.STRING }
        ]
      };

      const targetSchema = {
        columns: [
          { name: 'age', dataType: 'INTEGER', universalType: UNIVERSAL_TYPES.INTEGER }
        ]
      };

      const mappingRules = SchemaConverter.generateAutoMapping(sourceSchema, targetSchema);
      
      expect(mappingRules).toHaveLength(1);
      expect(mappingRules[0].transformationType).toEqual('stringToInteger');
    });
  });

  describe('Schema Diff', () => {
    it('should create schema diff report', () => {
      const schema1 = {
        columns: [
          { name: 'id', dataType: 'INTEGER' },
          { name: 'name', dataType: 'VARCHAR' },
          { name: 'email', dataType: 'VARCHAR' }
        ]
      };

      const schema2 = {
        columns: [
          { name: 'id', dataType: 'BIGINT' },
          { name: 'name', dataType: 'VARCHAR' },
          { name: 'phone', dataType: 'VARCHAR' }
        ]
      };

      const diff = SchemaConverter.createSchemaDiff(schema1, schema2);
      
      expect(diff.added).toHaveLength(1);
      expect(diff.added[0].name).toEqual('phone');
      expect(diff.removed).toHaveLength(1);
      expect(diff.removed[0].name).toEqual('email');
      expect(diff.modified).toHaveLength(1);
      expect(diff.modified[0].column).toEqual('id');
    });

    it('should detect unchanged columns', () => {
      const schema1 = {
        columns: [
          { name: 'id', dataType: 'INTEGER' },
          { name: 'name', dataType: 'VARCHAR' }
        ]
      };

      const schema2 = {
        columns: [
          { name: 'id', dataType: 'INTEGER' },
          { name: 'name', dataType: 'VARCHAR' }
        ]
      };

      const diff = SchemaConverter.createSchemaDiff(schema1, schema2);
      
      expect(diff.unchanged).toHaveLength(2);
      expect(diff.added).toHaveLength(0);
      expect(diff.removed).toHaveLength(0);
      expect(diff.modified).toHaveLength(0);
    });
  });

  describe('Name Similarity', () => {
    it('should calculate name similarity correctly', () => {
      // Exact match
      expect(SchemaConverter.calculateNameSimilarity('user_id', 'user_id')).toEqual(1.0);
      
      // Case and underscore variations
      expect(SchemaConverter.calculateNameSimilarity('user_id', 'userid')).toEqual(1.0);
      expect(SchemaConverter.calculateNameSimilarity('user_id', 'UserId')).toEqual(1.0);
      
      // Partial matches
      expect(SchemaConverter.calculateNameSimilarity('user_id', 'id')).toBeGreaterThan(0.7);
      expect(SchemaConverter.calculateNameSimilarity('customer_name', 'name')).toBeGreaterThan(0.7);
      
      // Low similarity
      expect(SchemaConverter.calculateNameSimilarity('name', 'description')).toBeLessThan(0.5);
      expect(SchemaConverter.calculateNameSimilarity('age', 'email')).toBeLessThan(0.5);
    });
  });

  describe('Transformation Type Detection', () => {
    it('should determine correct transformation types', () => {
      const testCases = [
        {
          source: { universalType: UNIVERSAL_TYPES.STRING },
          target: { universalType: UNIVERSAL_TYPES.INTEGER },
          expected: 'stringToInteger'
        },
        {
          source: { universalType: UNIVERSAL_TYPES.INTEGER },
          target: { universalType: UNIVERSAL_TYPES.STRING },
          expected: 'integerToString'
        },
        {
          source: { universalType: UNIVERSAL_TYPES.DATE },
          target: { universalType: UNIVERSAL_TYPES.TIMESTAMP },
          expected: 'dateToTimestamp'
        },
        {
          source: { universalType: UNIVERSAL_TYPES.STRING },
          target: { universalType: UNIVERSAL_TYPES.STRING },
          expected: 'direct'
        }
      ];

      testCases.forEach(({ source, target, expected }) => {
        const result = SchemaConverter.determineTransformationType(source, target);
        expect(result).toEqual(expected);
      });
    });
  });
});