const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const logger = require('../utils/logger');
const auditLogger = require('./auditLogger');

/**
 * 취약점 스캔 서비스
 * 다양한 보안 스캔 도구들을 통합하여 자동화된 취약점 검사 수행
 */
class VulnerabilityScanner {
  constructor() {
    this.scanners = new Map();
    this.scanHistory = [];
    this.config = {
      maxHistorySize: 100,
      scanTimeout: 300000, // 5분
      reportDirectory: path.join(__dirname, '../reports/security'),
      enabledScanners: process.env.ENABLED_SCANNERS?.split(',') || ['dependency', 'secrets', 'code'],
      scheduledScans: {
        dependency: { interval: '0 2 * * *', enabled: true }, // 매일 새벽 2시
        secrets: { interval: '0 3 * * *', enabled: true },     // 매일 새벽 3시
        code: { interval: '0 4 * * 1', enabled: true }        // 매주 월요일 새벽 4시
      }
    };

    this.initializeScanners();
    this.ensureReportDirectory();
  }

  /**
   * 스캐너 초기화
   */
  initializeScanners() {
    // Dependency 스캔 (npm audit, yarn audit)
    this.scanners.set('dependency', {
      name: 'Dependency Vulnerability Scanner',
      description: 'NPM/Yarn 패키지 취약점 검사',
      command: 'npm',
      args: ['audit', '--json'],
      parser: this.parseNpmAuditResult.bind(this),
      enabled: true
    });

    // Secret 스캔 (truffleHog 시뮬레이션)
    this.scanners.set('secrets', {
      name: 'Secret Scanner',
      description: '하드코딩된 시크릿 및 API 키 검사',
      command: null, // 자체 구현
      parser: this.parseSecretScanResult.bind(this),
      enabled: true
    });

    // 코드 품질 스캔 (ESLint Security 플러그인 시뮬레이션)
    this.scanners.set('code', {
      name: 'Code Security Scanner',
      description: '코드 보안 취약점 정적 분석',
      command: null, // 자체 구현
      parser: this.parseCodeScanResult.bind(this),
      enabled: true
    });

    // Docker 이미지 스캔 (Trivy 시뮬레이션)
    this.scanners.set('docker', {
      name: 'Docker Image Scanner',
      description: 'Docker 이미지 취약점 검사',
      command: null, // 자체 구현
      parser: this.parseDockerScanResult.bind(this),
      enabled: false // 기본 비활성화
    });

    // 웹 애플리케이션 스캔 (OWASP ZAP 시뮬레이션)
    this.scanners.set('webapp', {
      name: 'Web Application Scanner',
      description: 'OWASP Top 10 취약점 검사',
      command: null, // 자체 구현
      parser: this.parseWebAppScanResult.bind(this),
      enabled: false // 기본 비활성화
    });

    logger.info('취약점 스캐너 초기화 완료:', {
      totalScanners: this.scanners.size,
      enabledScanners: Array.from(this.scanners.values()).filter(s => s.enabled).length
    });
  }

  /**
   * 리포트 디렉토리 생성
   */
  ensureReportDirectory() {
    if (!fs.existsSync(this.config.reportDirectory)) {
      fs.mkdirSync(this.config.reportDirectory, { recursive: true });
      logger.info('보안 리포트 디렉토리 생성:', { path: this.config.reportDirectory });
    }
  }

  /**
   * 전체 보안 스캔 실행
   * @param {Object} options - 스캔 옵션
   * @returns {Object} 스캔 결과
   */
  async runFullScan(options = {}) {
    const scanId = this.generateScanId();
    const startTime = new Date();
    
    logger.info('전체 보안 스캔 시작:', { scanId, options });

    try {
      const scanTypes = options.scanTypes || this.config.enabledScanners;
      const results = {};
      const errors = [];

      for (const scanType of scanTypes) {
        if (!this.scanners.has(scanType)) {
          errors.push(`Unknown scanner: ${scanType}`);
          continue;
        }

        try {
          logger.info(`${scanType} 스캔 시작`);
          const result = await this.runScan(scanType, options);
          results[scanType] = result;
          logger.info(`${scanType} 스캔 완료:`, { 
            vulnerabilities: result.vulnerabilities.length,
            riskScore: result.riskScore 
          });
        } catch (error) {
          logger.error(`${scanType} 스캔 실패:`, error);
          errors.push(`${scanType}: ${error.message}`);
        }
      }

      const endTime = new Date();
      const duration = endTime - startTime;
      
      // 전체 결과 취합
      const summary = this.generateScanSummary(results);
      
      const fullScanResult = {
        scanId,
        startTime,
        endTime,
        duration,
        results,
        summary,
        errors,
        reportPath: await this.generateReport(scanId, results, summary)
      };

      // 스캔 히스토리에 추가
      this.addToHistory(fullScanResult);

      // 감사 로그 기록
      await auditLogger.log({
        type: 'SECURITY_SCAN_COMPLETED',
        action: 'SCAN',
        resource: 'security',
        result: errors.length > 0 ? 'PARTIAL_SUCCESS' : 'SUCCESS',
        severity: summary.riskLevel,
        metadata: {
          scanId,
          duration,
          vulnerabilityCount: summary.totalVulnerabilities,
          riskScore: summary.overallRiskScore,
          scanTypes,
          errors: errors.length
        }
      });

      logger.info('전체 보안 스캔 완료:', {
        scanId,
        duration,
        vulnerabilities: summary.totalVulnerabilities,
        riskScore: summary.overallRiskScore
      });

      return fullScanResult;
    } catch (error) {
      logger.error('전체 보안 스캔 실패:', error);
      throw error;
    }
  }

  /**
   * 개별 스캔 실행
   * @param {string} scanType - 스캔 타입
   * @param {Object} options - 스캔 옵션
   * @returns {Object} 스캔 결과
   */
  async runScan(scanType, options = {}) {
    const scanner = this.scanners.get(scanType);
    
    if (!scanner) {
      throw new Error(`Scanner not found: ${scanType}`);
    }

    if (!scanner.enabled) {
      throw new Error(`Scanner disabled: ${scanType}`);
    }

    const startTime = new Date();
    
    try {
      let rawResult;
      
      if (scanner.command) {
        // 외부 도구 실행
        rawResult = await this.executeCommand(scanner.command, scanner.args, options);
      } else {
        // 자체 구현 스캔
        rawResult = await this.executeSelfImplementedScan(scanType, options);
      }

      // 결과 파싱
      const parsedResult = await scanner.parser(rawResult, options);
      
      const endTime = new Date();
      const duration = endTime - startTime;

      return {
        scanType,
        scannerName: scanner.name,
        startTime,
        endTime,
        duration,
        vulnerabilities: parsedResult.vulnerabilities,
        riskScore: this.calculateRiskScore(parsedResult.vulnerabilities),
        metadata: parsedResult.metadata || {}
      };
    } catch (error) {
      logger.error(`${scanType} 스캔 실행 실패:`, error);
      throw error;
    }
  }

  /**
   * 외부 명령어 실행
   * @param {string} command - 실행할 명령어
   * @param {Array} args - 명령어 인수
   * @param {Object} options - 옵션
   * @returns {string} 실행 결과
   */
  async executeCommand(command, args, options = {}) {
    return new Promise((resolve, reject) => {
      const timeout = options.timeout || this.config.scanTimeout;
      let output = '';
      let errorOutput = '';

      const process = spawn(command, args, {
        cwd: options.workingDirectory || process.cwd(),
        env: { ...process.env, ...options.env }
      });

      const timer = setTimeout(() => {
        process.kill('SIGKILL');
        reject(new Error(`Command timeout: ${command} ${args.join(' ')}`));
      }, timeout);

      process.stdout.on('data', (data) => {
        output += data.toString();
      });

      process.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      process.on('close', (code) => {
        clearTimeout(timer);
        
        if (code === 0 || (command === 'npm' && args[0] === 'audit')) {
          // npm audit는 취약점이 있어도 non-zero exit code 반환
          resolve(output);
        } else {
          reject(new Error(`Command failed with code ${code}: ${errorOutput}`));
        }
      });

      process.on('error', (error) => {
        clearTimeout(timer);
        reject(error);
      });
    });
  }

  /**
   * 자체 구현 스캔 실행
   * @param {string} scanType - 스캔 타입
   * @param {Object} options - 옵션
   * @returns {Object} 스캔 결과
   */
  async executeSelfImplementedScan(scanType, options = {}) {
    switch (scanType) {
      case 'secrets':
        return await this.scanForSecrets(options);
      case 'code':
        return await this.scanCodeSecurity(options);
      case 'docker':
        return await this.scanDockerImage(options);
      case 'webapp':
        return await this.scanWebApplication(options);
      default:
        throw new Error(`Self-implemented scanner not found: ${scanType}`);
    }
  }

  /**
   * 시크릿 스캔 (하드코딩된 시크릿 검사)
   */
  async scanForSecrets(options = {}) {
    const secretPatterns = [
      {
        name: 'AWS Access Key',
        pattern: /AKIA[0-9A-Z]{16}/g,
        severity: 'HIGH'
      },
      {
        name: 'AWS Secret Key',
        pattern: /[0-9a-zA-Z/+]{40}/g,
        severity: 'HIGH'
      },
      {
        name: 'API Key',
        pattern: /(?:api[_-]?key|apikey)[\s]*[:=][\s]*['"][a-zA-Z0-9]{16,}['"]/gi,
        severity: 'MEDIUM'
      },
      {
        name: 'JWT Token',
        pattern: /eyJ[a-zA-Z0-9_-]+\.eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+/g,
        severity: 'MEDIUM'
      },
      {
        name: 'Database URL',
        pattern: /(?:mysql|postgres|mongodb):\/\/[a-zA-Z0-9_.:@-]+/gi,
        severity: 'HIGH'
      },
      {
        name: 'Private Key',
        pattern: /-----BEGIN (?:RSA )?PRIVATE KEY-----/g,
        severity: 'CRITICAL'
      }
    ];

    const results = [];
    const scanDirectory = options.directory || process.cwd();
    
    // 제외할 디렉토리/파일
    const excludePatterns = [
      'node_modules',
      '.git',
      'dist',
      'build',
      '.env.example',
      '*.log',
      '*.test.js',
      '*.spec.js'
    ];

    try {
      const files = this.getFilesToScan(scanDirectory, excludePatterns);
      
      for (const filePath of files) {
        try {
          const content = fs.readFileSync(filePath, 'utf8');
          
          for (const pattern of secretPatterns) {
            const matches = content.match(pattern.pattern);
            
            if (matches) {
              matches.forEach((match, index) => {
                const lines = content.substring(0, content.indexOf(match)).split('\n');
                const lineNumber = lines.length;
                
                results.push({
                  type: pattern.name,
                  severity: pattern.severity,
                  file: path.relative(scanDirectory, filePath),
                  line: lineNumber,
                  match: match.substring(0, 50) + (match.length > 50 ? '...' : ''),
                  description: `Potential ${pattern.name} found in code`
                });
              });
            }
          }
        } catch (fileError) {
          logger.debug('파일 읽기 실패:', { filePath, error: fileError.message });
        }
      }
    } catch (error) {
      logger.error('시크릿 스캔 실패:', error);
      throw error;
    }

    return { secrets: results };
  }

  /**
   * 코드 보안 스캔
   */
  async scanCodeSecurity(options = {}) {
    const securityIssues = [];
    const scanDirectory = options.directory || process.cwd();
    
    // 보안 취약점 패턴
    const securityPatterns = [
      {
        name: 'SQL Injection Risk',
        pattern: /(?:SELECT|INSERT|UPDATE|DELETE).*?\+.*?(?:req\.|params\.|query\.)/gi,
        severity: 'HIGH',
        description: 'Potential SQL injection vulnerability'
      },
      {
        name: 'XSS Risk',
        pattern: /innerHTML\s*=\s*.*?(?:req\.|params\.|query\.)/gi,
        severity: 'MEDIUM',
        description: 'Potential XSS vulnerability'
      },
      {
        name: 'Command Injection Risk',
        pattern: /exec\s*\(\s*.*?(?:req\.|params\.|query\.)/gi,
        severity: 'CRITICAL',
        description: 'Potential command injection vulnerability'
      },
      {
        name: 'Path Traversal Risk',
        pattern: /(?:readFile|writeFile)\s*\(\s*.*?(?:req\.|params\.|query\.)/gi,
        severity: 'HIGH',
        description: 'Potential path traversal vulnerability'
      },
      {
        name: 'Insecure Random',
        pattern: /Math\.random\(\)/g,
        severity: 'LOW',
        description: 'Use of insecure random number generator'
      },
      {
        name: 'Hardcoded Password',
        pattern: /(?:password|passwd|pwd)[\s]*[:=][\s]*['"][^'"]{3,}['"]/gi,
        severity: 'HIGH',
        description: 'Hardcoded password detected'
      }
    ];

    try {
      const jsFiles = this.getFilesToScan(scanDirectory, ['node_modules', '.git'], ['.js', '.ts']);
      
      for (const filePath of jsFiles) {
        try {
          const content = fs.readFileSync(filePath, 'utf8');
          
          for (const pattern of securityPatterns) {
            const matches = [...content.matchAll(pattern.pattern)];
            
            matches.forEach(match => {
              const lines = content.substring(0, match.index).split('\n');
              const lineNumber = lines.length;
              const lineContent = lines[lines.length - 1] + match[0];
              
              securityIssues.push({
                type: pattern.name,
                severity: pattern.severity,
                file: path.relative(scanDirectory, filePath),
                line: lineNumber,
                code: lineContent.trim(),
                description: pattern.description
              });
            });
          }
        } catch (fileError) {
          logger.debug('파일 읽기 실패:', { filePath, error: fileError.message });
        }
      }
    } catch (error) {
      logger.error('코드 보안 스캔 실패:', error);
      throw error;
    }

    return { codeIssues: securityIssues };
  }

  /**
   * Docker 이미지 스캔 (시뮬레이션)
   */
  async scanDockerImage(options = {}) {
    // 실제로는 Trivy, Clair 등의 도구 사용
    const mockVulnerabilities = [
      {
        type: 'Package Vulnerability',
        severity: 'HIGH',
        package: 'libssl1.1',
        version: '1.1.1f-1ubuntu2.16',
        cve: 'CVE-2023-0286',
        description: 'OpenSSL vulnerability in X.400 certificate validation'
      }
    ];

    return { dockerVulnerabilities: mockVulnerabilities };
  }

  /**
   * 웹 애플리케이션 스캔 (시뮬레이션)
   */
  async scanWebApplication(options = {}) {
    // 실제로는 OWASP ZAP, Burp Suite 등의 도구 사용
    const mockFindings = [
      {
        type: 'Missing Security Headers',
        severity: 'MEDIUM',
        url: options.baseUrl || 'http://localhost:3000',
        description: 'X-Content-Type-Options header missing'
      }
    ];

    return { webAppFindings: mockFindings };
  }

  /**
   * NPM Audit 결과 파싱
   */
  async parseNpmAuditResult(rawResult, options) {
    try {
      const auditData = JSON.parse(rawResult);
      const vulnerabilities = [];

      if (auditData.vulnerabilities) {
        for (const [packageName, vulnInfo] of Object.entries(auditData.vulnerabilities)) {
          if (vulnInfo.via && Array.isArray(vulnInfo.via)) {
            vulnInfo.via.forEach(via => {
              if (typeof via === 'object' && via.title) {
                vulnerabilities.push({
                  type: 'Dependency Vulnerability',
                  severity: via.severity?.toUpperCase() || 'UNKNOWN',
                  package: packageName,
                  version: vulnInfo.range || 'unknown',
                  cve: via.cwe ? `CWE-${via.cwe.join(', CWE-')}` : null,
                  title: via.title,
                  description: via.overview || via.title,
                  url: via.url
                });
              }
            });
          }
        }
      }

      return {
        vulnerabilities,
        metadata: {
          auditedPackages: auditData.metadata?.totalDependencies || 0,
          knownVulnerabilities: auditData.metadata?.vulnerabilities || 0
        }
      };
    } catch (error) {
      logger.error('NPM Audit 결과 파싱 실패:', error);
      throw error;
    }
  }

  /**
   * 시크릿 스캔 결과 파싱
   */
  async parseSecretScanResult(rawResult, options) {
    const vulnerabilities = rawResult.secrets.map(secret => ({
      type: 'Exposed Secret',
      severity: secret.severity,
      file: secret.file,
      line: secret.line,
      secretType: secret.type,
      description: secret.description,
      match: secret.match
    }));

    return {
      vulnerabilities,
      metadata: {
        filesScanned: rawResult.filesScanned || 0,
        secretsFound: vulnerabilities.length
      }
    };
  }

  /**
   * 코드 스캔 결과 파싱
   */
  async parseCodeScanResult(rawResult, options) {
    const vulnerabilities = rawResult.codeIssues.map(issue => ({
      type: 'Code Security Issue',
      severity: issue.severity,
      file: issue.file,
      line: issue.line,
      issueType: issue.type,
      description: issue.description,
      code: issue.code
    }));

    return {
      vulnerabilities,
      metadata: {
        filesScanned: rawResult.filesScanned || 0,
        issuesFound: vulnerabilities.length
      }
    };
  }

  /**
   * Docker 스캔 결과 파싱
   */
  async parseDockerScanResult(rawResult, options) {
    const vulnerabilities = rawResult.dockerVulnerabilities.map(vuln => ({
      type: 'Container Vulnerability',
      severity: vuln.severity,
      package: vuln.package,
      version: vuln.version,
      cve: vuln.cve,
      description: vuln.description
    }));

    return { vulnerabilities };
  }

  /**
   * 웹앱 스캔 결과 파싱
   */
  async parseWebAppScanResult(rawResult, options) {
    const vulnerabilities = rawResult.webAppFindings.map(finding => ({
      type: 'Web Application Vulnerability',
      severity: finding.severity,
      url: finding.url,
      findingType: finding.type,
      description: finding.description
    }));

    return { vulnerabilities };
  }

  /**
   * 위험도 점수 계산
   */
  calculateRiskScore(vulnerabilities) {
    let score = 0;
    
    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'CRITICAL': score += 25; break;
        case 'HIGH': score += 15; break;
        case 'MEDIUM': score += 8; break;
        case 'LOW': score += 3; break;
        default: score += 1; break;
      }
    });

    return Math.min(score, 100);
  }

  /**
   * 스캔 요약 생성
   */
  generateScanSummary(results) {
    let totalVulnerabilities = 0;
    let totalRiskScore = 0;
    let scanCount = 0;
    
    const severityCounts = {
      CRITICAL: 0,
      HIGH: 0,
      MEDIUM: 0,
      LOW: 0
    };

    for (const [scanType, result] of Object.entries(results)) {
      totalVulnerabilities += result.vulnerabilities.length;
      totalRiskScore += result.riskScore;
      scanCount++;

      result.vulnerabilities.forEach(vuln => {
        if (severityCounts.hasOwnProperty(vuln.severity)) {
          severityCounts[vuln.severity]++;
        }
      });
    }

    const overallRiskScore = scanCount > 0 ? Math.round(totalRiskScore / scanCount) : 0;
    const riskLevel = this.getRiskLevel(overallRiskScore);

    return {
      totalVulnerabilities,
      overallRiskScore,
      riskLevel,
      severityCounts,
      scanTypes: Object.keys(results),
      scanCount
    };
  }

  /**
   * 위험도 레벨 계산
   */
  getRiskLevel(score) {
    if (score >= 80) return 'CRITICAL';
    if (score >= 60) return 'HIGH';
    if (score >= 30) return 'MEDIUM';
    return 'LOW';
  }

  /**
   * 스캔할 파일 목록 생성
   */
  getFilesToScan(directory, excludePatterns = [], extensions = null) {
    const files = [];
    
    const scanDir = (dir) => {
      try {
        const entries = fs.readdirSync(dir);
        
        for (const entry of entries) {
          const fullPath = path.join(dir, entry);
          const stat = fs.statSync(fullPath);
          
          // 제외 패턴 확인
          if (excludePatterns.some(pattern => 
            entry.includes(pattern) || fullPath.includes(pattern)
          )) {
            continue;
          }
          
          if (stat.isDirectory()) {
            scanDir(fullPath);
          } else if (stat.isFile()) {
            // 확장자 필터링
            if (!extensions || extensions.some(ext => entry.endsWith(ext))) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        logger.debug('디렉토리 스캔 실패:', { dir, error: error.message });
      }
    };

    scanDir(directory);
    return files;
  }

  /**
   * 리포트 생성
   */
  async generateReport(scanId, results, summary) {
    const reportData = {
      scanId,
      generatedAt: new Date().toISOString(),
      summary,
      results,
      recommendations: this.generateRecommendations(results)
    };

    const reportPath = path.join(
      this.config.reportDirectory,
      `security-scan-${scanId}.json`
    );

    try {
      fs.writeFileSync(reportPath, JSON.stringify(reportData, null, 2));
      logger.info('보안 스캔 리포트 생성:', { reportPath });
      return reportPath;
    } catch (error) {
      logger.error('리포트 생성 실패:', error);
      return null;
    }
  }

  /**
   * 권장사항 생성
   */
  generateRecommendations(results) {
    const recommendations = [];

    for (const [scanType, result] of Object.entries(results)) {
      if (result.vulnerabilities.length > 0) {
        const criticalCount = result.vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
        const highCount = result.vulnerabilities.filter(v => v.severity === 'HIGH').length;

        if (criticalCount > 0) {
          recommendations.push({
            priority: 'CRITICAL',
            category: scanType,
            title: `${criticalCount}개의 치명적 취약점 발견`,
            description: `${scanType} 스캔에서 치명적인 보안 취약점이 발견되었습니다. 즉시 수정이 필요합니다.`,
            action: '해당 취약점들을 우선적으로 패치하거나 완화 조치를 취하세요.'
          });
        }

        if (highCount > 0) {
          recommendations.push({
            priority: 'HIGH',
            category: scanType,
            title: `${highCount}개의 높은 위험도 취약점 발견`,
            description: `${scanType} 스캔에서 높은 위험도의 보안 취약점이 발견되었습니다.`,
            action: '가능한 빨리 해당 취약점들을 수정하세요.'
          });
        }
      }
    }

    return recommendations;
  }

  /**
   * 스캔 히스토리에 추가
   */
  addToHistory(scanResult) {
    this.scanHistory.unshift(scanResult);
    
    if (this.scanHistory.length > this.config.maxHistorySize) {
      this.scanHistory = this.scanHistory.slice(0, this.config.maxHistorySize);
    }
  }

  /**
   * 스캔 ID 생성
   */
  generateScanId() {
    return `scan_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  }

  /**
   * 스캔 히스토리 조회
   */
  getScanHistory(limit = 10) {
    return this.scanHistory.slice(0, limit);
  }

  /**
   * 특정 스캔 결과 조회
   */
  getScanResult(scanId) {
    return this.scanHistory.find(scan => scan.scanId === scanId);
  }

  /**
   * 스캐너 설정 조회
   */
  getScannerConfig() {
    return {
      availableScanners: Array.from(this.scanners.entries()).map(([key, scanner]) => ({
        id: key,
        name: scanner.name,
        description: scanner.description,
        enabled: scanner.enabled
      })),
      config: this.config
    };
  }

  /**
   * 스캐너 활성화/비활성화
   */
  toggleScanner(scannerId, enabled) {
    const scanner = this.scanners.get(scannerId);
    if (scanner) {
      scanner.enabled = enabled;
      logger.info(`스캐너 ${enabled ? '활성화' : '비활성화'}:`, { scannerId });
      return true;
    }
    return false;
  }
}

module.exports = new VulnerabilityScanner();