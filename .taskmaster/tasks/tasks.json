{
  "master": {
    "tasks": [
      {
        "id": 28,
        "title": "연결 테스트 프레임워크 구현",
        "description": "모든 지원 데이터베이스 유형에 대한 실시간 연결 테스트 기능을 구현하고, 타임아웃 설정, 사용자 정의 테스트 쿼리, SSL/TLS 검증을 포함한 포괄적인 연결 진단 기능을 개발합니다.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. ConnectionTestService.js 구현 완료:\n```javascript\n// ConnectionTestService.js\nclass ConnectionTestService {\n  async testConnection(systemId, options = {}) {\n    const { timeout = 30000, testQuery, validateSSL = true } = options;\n    const startTime = Date.now();\n    \n    try {\n      // 모든 데이터베이스 유형 지원\n      // - PostgreSQL, MySQL, Oracle, SQLite, MongoDB, Redis\n      // - 파일 시스템: SFTP, FTP, Local FS, AWS S3, Azure Blob\n      // - REST APIs, Kafka\n      const driver = this.getDriver(system.type);\n      const connection = await driver.connect({\n        ...system.connectionConfig,\n        connectTimeout: timeout,\n        ssl: validateSSL ? system.sslConfig : false\n      });\n      \n      // 연결 성능 측정\n      const connectionTime = Date.now() - startTime;\n      \n      // 테스트 쿼리 실행\n      const queryStart = Date.now();\n      await connection.query(testQuery || this.getDefaultTestQuery(system.type));\n      const queryTime = Date.now() - queryStart;\n      \n      return {\n        success: true,\n        connectionTime,\n        queryTime,\n        metrics: await this.collectMetrics(connection)\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.classifyError(error),\n        diagnostics: await this.runDiagnostics(system),\n        recommendations: this.getRecommendations(error)\n      };\n    }\n  }\n}\n```\n\n2. 향상된 Systems API 구현 완료:\n- GET /systems - 검색, 필터링, 페이지네이션 지원\n- POST /systems - 유효성 검사를 통한 생성\n- PUT /systems/:id - 유효성 검사를 통한 업데이트\n- DELETE /systems/:id - 오류 처리를 포함한 삭제\n- POST /systems/:id/test - 기존 시스템 연결 테스트\n- POST /systems/test-connection - 저장 없이 연결 테스트\n\n3. 데이터베이스 통합 - 연결 상태 추적:\n- lastConnectionStatus: 마지막 연결 상태\n- lastConnectionTest: 마지막 테스트 시간\n- lastConnectionMessage: 상세 메시지\n- lastConnectionLatency: 성능 모니터링을 위한 지연 시간\n- 각 테스트 후 결과 자동 저장\n\n4. 설치된 종속성:\n- 기존: pg v8.11.3, mysql2 v3.6.5, oracledb v6.3.0, tedious v16.6.1, mongodb v6.3.0, sqlite3 v5.1.6\n- 추가: ssh2, ftp, aws-sdk (추가 연결 유형 지원)",
        "testStrategy": "1. 단위 테스트: 각 데이터베이스 드라이버별 연결 테스트 (완료)\n2. 통합 테스트: Docker Compose를 사용한 실제 데이터베이스 연결 테스트 (완료)\n3. 성능 테스트: 실제 연결을 통한 동시 연결 테스트 검증\n4. 오류 시나리오 테스트: 실제 오류 처리 및 진단 기능 검증\n5. SSL/TLS 검증 테스트: 다양한 인증서 시나리오 처리 확인",
        "subtasks": [
          {
            "id": 1,
            "title": "ConnectionTestService.js 핵심 구현",
            "description": "모든 데이터베이스 유형을 지원하는 포괄적인 연결 테스트 서비스 구현",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Systems API 엔드포인트 구현",
            "description": "완전한 CRUD 작업 및 연결 테스트 엔드포인트 구현",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "데이터베이스 스키마 업데이트",
            "description": "연결 상태 추적을 위한 필드 추가 및 자동 저장 로직 구현",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "추가 연결 유형 지원",
            "description": "파일 시스템, REST API, Kafka 등 추가 연결 유형 구현",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "실제 연결 테스트 검증",
            "description": "모든 지원 시스템에 대한 실제 연결 테스트 및 오류 처리 검증",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 29,
        "title": "실시간 연결 상태 모니터링 시스템 구축",
        "description": "백그라운드 헬스 체크, 실시간 상태 표시기, 연결 성능 메트릭 수집 및 자동 재시도 메커니즘을 포함한 포괄적인 모니터링 시스템을 구현합니다.",
        "details": "1. 헬스 체크 스케줄러 구현 (Bull Queue v4.12.0 사용):\n```javascript\n// HealthCheckScheduler.js\nconst Queue = require('bull');\nconst healthCheckQueue = new Queue('health-checks', {\n  redis: { host: 'localhost', port: 6379 }\n});\n\nhealthCheckQueue.process(async (job) => {\n  const { systemId, interval } = job.data;\n  const result = await connectionTestService.testConnection(systemId);\n  \n  // 상태 업데이트 및 메트릭 저장\n  await systemService.updateStatus(systemId, result);\n  await metricsService.recordHealthCheck(systemId, result);\n  \n  // WebSocket으로 실시간 업데이트 전송\n  io.to(`system:${systemId}`).emit('status-update', result);\n  \n  // 다음 체크 스케줄링\n  await healthCheckQueue.add(\n    { systemId, interval },\n    { delay: interval * 1000 }\n  );\n});\n```\n\n2. WebSocket 서버 구현 (Socket.io v4.6.1):\n```javascript\nconst io = require('socket.io')(server, {\n  cors: { origin: '*' },\n  transports: ['websocket', 'polling']\n});\n\nio.on('connection', (socket) => {\n  socket.on('subscribe-system', (systemId) => {\n    socket.join(`system:${systemId}`);\n  });\n});\n```\n\n3. 메트릭 수집 서비스:\n```javascript\nclass MetricsService {\n  async recordHealthCheck(systemId, result) {\n    const metrics = {\n      timestamp: new Date(),\n      systemId,\n      status: result.success ? 'healthy' : 'error',\n      responseTime: result.connectionTime,\n      errorRate: await this.calculateErrorRate(systemId),\n      throughput: await this.calculateThroughput(systemId)\n    };\n    \n    // Prometheus 메트릭 업데이트\n    connectionGauge.set({ system: systemId }, result.success ? 1 : 0);\n    responseTimeHistogram.observe({ system: systemId }, result.connectionTime);\n    \n    // 시계열 데이터베이스 저장 (InfluxDB)\n    await influxDB.writePoints([{\n      measurement: 'system_health',\n      tags: { systemId },\n      fields: metrics\n    }]);\n  }\n}\n```\n\n4. 자동 재시도 메커니즘:\n```javascript\nclass RetryManager {\n  async executeWithRetry(fn, options = {}) {\n    const { maxRetries = 3, backoff = 'exponential' } = options;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        if (attempt === maxRetries) throw error;\n        \n        const delay = this.calculateDelay(attempt, backoff);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n}\n```",
        "testStrategy": "1. 헬스 체크 정확도 테스트: 모의 장애 시나리오에서 99% 이상 정확도 검증\n2. WebSocket 연결 테스트: 1000개 이상의 동시 클라이언트 연결 처리\n3. 메트릭 수집 성능 테스트: 시스템 리소스 1% 미만 사용 확인\n4. 재시도 메커니즘 테스트: 다양한 실패 시나리오에서 복구 검증\n5. 부하 테스트: K6를 사용한 대규모 모니터링 시뮬레이션",
        "priority": "high",
        "dependencies": [
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "고급 보안 및 자격 증명 관리 시스템 구현",
        "description": "AES-256 암호화, 외부 시크릿 관리 시스템 통합, 자격 증명 로테이션, 감사 로깅 및 역할 기반 액세스 제어를 포함한 엔터프라이즈급 보안 시스템을 구축합니다.",
        "details": "1. 암호화 서비스 구현 (crypto-js v4.2.0):\n```javascript\n// EncryptionService.js\nconst CryptoJS = require('crypto-js');\nconst { generateKeyPairSync } = require('crypto');\n\nclass EncryptionService {\n  constructor() {\n    this.masterKey = this.deriveMasterKey();\n  }\n  \n  encrypt(plaintext) {\n    const iv = CryptoJS.lib.WordArray.random(16);\n    const encrypted = CryptoJS.AES.encrypt(plaintext, this.masterKey, {\n      iv: iv,\n      mode: CryptoJS.mode.CBC,\n      padding: CryptoJS.pad.Pkcs7\n    });\n    \n    return {\n      ciphertext: encrypted.toString(),\n      iv: iv.toString(CryptoJS.enc.Base64)\n    };\n  }\n  \n  decrypt(ciphertext, iv) {\n    const decrypted = CryptoJS.AES.decrypt(ciphertext, this.masterKey, {\n      iv: CryptoJS.enc.Base64.parse(iv),\n      mode: CryptoJS.mode.CBC,\n      padding: CryptoJS.pad.Pkcs7\n    });\n    \n    return decrypted.toString(CryptoJS.enc.Utf8);\n  }\n}\n```\n\n2. 외부 시크릿 관리 통합:\n```javascript\n// SecretManager.js\nclass SecretManager {\n  constructor() {\n    this.providers = {\n      vault: new HashiCorpVaultProvider(),\n      aws: new AWSSecretsManagerProvider(),\n      azure: new AzureKeyVaultProvider()\n    };\n  }\n  \n  async getSecret(secretPath, provider = 'vault') {\n    const secretProvider = this.providers[provider];\n    return await secretProvider.getSecret(secretPath);\n  }\n  \n  async rotateCredentials(systemId) {\n    const newCredentials = await this.generateNewCredentials();\n    await this.updateSystemCredentials(systemId, newCredentials);\n    await this.auditLog('credential_rotation', { systemId });\n  }\n}\n```\n\n3. 감사 로깅 시스템:\n```javascript\n// AuditLogger.js\nclass AuditLogger {\n  async log(event, details) {\n    const auditEntry = {\n      timestamp: new Date().toISOString(),\n      eventType: event,\n      userId: details.userId,\n      ipAddress: details.ipAddress,\n      userAgent: details.userAgent,\n      resource: details.resource,\n      action: details.action,\n      result: details.result,\n      metadata: details.metadata\n    };\n    \n    // 데이터베이스 저장\n    await db.auditLogs.create(auditEntry);\n    \n    // SIEM 시스템 전송\n    await siemClient.send(auditEntry);\n  }\n}\n```\n\n4. RBAC 구현 (casl v6.5.1):\n```javascript\n// abilities.js\nconst { defineAbility } = require('@casl/ability');\n\nfunction defineAbilitiesFor(user) {\n  return defineAbility((can, cannot) => {\n    if (user.role === 'admin') {\n      can('manage', 'all');\n    } else if (user.role === 'engineer') {\n      can('read', 'System');\n      can('test', 'System');\n      cannot('delete', 'System');\n      cannot('read', 'System', 'credentials');\n    }\n  });\n}\n```",
        "testStrategy": "1. 암호화 테스트: FIPS 140-2 준수 검증, 암호화/복호화 정확성 테스트\n2. 시크릿 관리 통합 테스트: HashiCorp Vault, AWS Secrets Manager 실제 연동\n3. 감사 로그 완전성 테스트: 100% 이벤트 캡처 확인\n4. RBAC 테스트: 다양한 역할별 권한 시나리오 검증\n5. 보안 취약점 스캔: OWASP ZAP, SonarQube 사용",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "포괄적인 데이터베이스 지원 확장",
        "description": "PostgreSQL, MySQL, Oracle, SQL Server, MongoDB, SQLite 및 클라우드 데이터베이스를 포함한 다양한 데이터베이스 유형에 대한 고급 연결 옵션과 특화된 기능을 구현합니다.",
        "details": "1. 데이터베이스별 어댑터 구현:\n```javascript\n// adapters/PostgreSQLAdapter.js\nclass PostgreSQLAdapter extends BaseAdapter {\n  async connect(config) {\n    const { Pool } = require('pg');\n    \n    const poolConfig = {\n      host: config.host,\n      port: config.port,\n      database: config.database,\n      user: config.user,\n      password: await this.decryptPassword(config.password),\n      ssl: config.ssl ? {\n        rejectUnauthorized: config.sslRejectUnauthorized,\n        ca: config.sslCa,\n        cert: config.sslCert,\n        key: config.sslKey\n      } : false,\n      max: config.poolSize || 20,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 2000\n    };\n    \n    this.pool = new Pool(poolConfig);\n    \n    // 연결 이벤트 리스너\n    this.pool.on('error', (err) => {\n      logger.error('PostgreSQL pool error', err);\n    });\n    \n    return this.pool;\n  }\n  \n  async testConnection() {\n    const client = await this.pool.connect();\n    try {\n      const result = await client.query('SELECT version()');\n      return { success: true, version: result.rows[0].version };\n    } finally {\n      client.release();\n    }\n  }\n}\n```\n\n2. Oracle 특화 기능:\n```javascript\n// adapters/OracleAdapter.js\nclass OracleAdapter extends BaseAdapter {\n  async connect(config) {\n    const oracledb = require('oracledb');\n    oracledb.outFormat = oracledb.OUT_FORMAT_OBJECT;\n    oracledb.autoCommit = true;\n    \n    // TNS 또는 Easy Connect 지원\n    const connectionString = config.tnsName || \n      `${config.host}:${config.port}/${config.serviceName}`;\n    \n    this.pool = await oracledb.createPool({\n      user: config.user,\n      password: await this.decryptPassword(config.password),\n      connectString: connectionString,\n      poolMin: 10,\n      poolMax: config.poolSize || 40,\n      poolIncrement: 5,\n      poolTimeout: 60\n    });\n    \n    return this.pool;\n  }\n}\n```\n\n3. MongoDB 레플리카셋 지원:\n```javascript\n// adapters/MongoDBAdapter.js\nclass MongoDBAdapter extends BaseAdapter {\n  async connect(config) {\n    const { MongoClient } = require('mongodb');\n    \n    let uri;\n    if (config.replicaSet) {\n      // 레플리카셋 연결 문자열\n      const hosts = config.hosts.map(h => `${h.host}:${h.port}`).join(',');\n      uri = `mongodb://${config.user}:${config.password}@${hosts}/${config.database}?replicaSet=${config.replicaSet}`;\n    } else {\n      uri = `mongodb://${config.user}:${config.password}@${config.host}:${config.port}/${config.database}`;\n    }\n    \n    this.client = new MongoClient(uri, {\n      maxPoolSize: config.poolSize || 50,\n      serverSelectionTimeoutMS: 5000,\n      socketTimeoutMS: 45000\n    });\n    \n    await this.client.connect();\n    return this.client;\n  }\n}\n```\n\n4. 클라우드 데이터베이스 자동 검색:\n```javascript\n// CloudDatabaseDiscovery.js\nclass CloudDatabaseDiscovery {\n  async discoverAWSRDS() {\n    const AWS = require('aws-sdk');\n    const rds = new AWS.RDS();\n    \n    const instances = await rds.describeDBInstances().promise();\n    return instances.DBInstances.map(instance => ({\n      name: instance.DBInstanceIdentifier,\n      engine: instance.Engine,\n      endpoint: instance.Endpoint.Address,\n      port: instance.Endpoint.Port,\n      status: instance.DBInstanceStatus\n    }));\n  }\n}\n```",
        "testStrategy": "1. 각 데이터베이스 어댑터 단위 테스트: 연결, 쿼리, 트랜잭션 기능\n2. 통합 테스트: Docker Compose로 모든 데이터베이스 유형 테스트 환경 구성\n3. 클라우드 통합 테스트: LocalStack을 사용한 AWS RDS 시뮬레이션\n4. 성능 벤치마크: 각 데이터베이스별 연결 풀 최적화 검증\n5. 호환성 테스트: 다양한 데이터베이스 버전과의 호환성 확인",
        "priority": "medium",
        "dependencies": [
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "연결 풀링 및 성능 최적화 시스템 구현",
        "description": "구성 가능한 연결 풀 설정, 연결 수명 주기 관리, 성능 모니터링 및 자동 스케일링을 포함한 고성능 연결 관리 시스템을 구축합니다.",
        "details": "1. 통합 연결 풀 관리자:\n```javascript\n// ConnectionPoolManager.js\nclass ConnectionPoolManager {\n  constructor() {\n    this.pools = new Map();\n    this.metrics = new PoolMetrics();\n  }\n  \n  async createPool(systemId, config) {\n    const poolConfig = {\n      min: config.minConnections || 2,\n      max: config.maxConnections || 10,\n      acquireTimeoutMillis: config.acquireTimeout || 30000,\n      createTimeoutMillis: config.createTimeout || 30000,\n      destroyTimeoutMillis: config.destroyTimeout || 5000,\n      idleTimeoutMillis: config.idleTimeout || 30000,\n      reapIntervalMillis: config.reapInterval || 1000,\n      createRetryIntervalMillis: 200,\n      propagateCreateError: false\n    };\n    \n    const pool = genericPool.createPool({\n      create: async () => {\n        const connection = await this.createConnection(systemId);\n        this.metrics.recordConnectionCreated(systemId);\n        return connection;\n      },\n      destroy: async (connection) => {\n        await connection.close();\n        this.metrics.recordConnectionDestroyed(systemId);\n      },\n      validate: async (connection) => {\n        return await this.validateConnection(connection);\n      }\n    }, poolConfig);\n    \n    // 풀 이벤트 모니터링\n    pool.on('factoryCreateError', (err) => {\n      logger.error(`Pool creation error for ${systemId}:`, err);\n      this.metrics.recordError(systemId, 'create_error');\n    });\n    \n    pool.on('factoryDestroyError', (err) => {\n      logger.error(`Pool destroy error for ${systemId}:`, err);\n      this.metrics.recordError(systemId, 'destroy_error');\n    });\n    \n    this.pools.set(systemId, pool);\n    return pool;\n  }\n  \n  async getConnection(systemId) {\n    const pool = this.pools.get(systemId);\n    if (!pool) {\n      throw new Error(`No pool found for system ${systemId}`);\n    }\n    \n    const startTime = Date.now();\n    const connection = await pool.acquire();\n    const acquireTime = Date.now() - startTime;\n    \n    this.metrics.recordAcquireTime(systemId, acquireTime);\n    \n    // 연결 래퍼로 자동 반환\n    return new ConnectionWrapper(connection, pool, this.metrics);\n  }\n}\n```\n\n2. 성능 메트릭 수집:\n```javascript\n// PoolMetrics.js\nclass PoolMetrics {\n  constructor() {\n    this.prometheus = new PrometheusClient();\n  }\n  \n  recordAcquireTime(systemId, time) {\n    this.prometheus.histogram('connection_acquire_time', time, { system: systemId });\n  }\n  \n  async getPoolStats(systemId) {\n    const pool = poolManager.getPool(systemId);\n    return {\n      size: pool.size,\n      available: pool.available,\n      borrowed: pool.borrowed,\n      pending: pool.pending,\n      max: pool.max,\n      min: pool.min\n    };\n  }\n  \n  async analyzePerformance(systemId) {\n    const stats = await this.getPoolStats(systemId);\n    const recommendations = [];\n    \n    if (stats.pending > 0 && stats.borrowed === stats.max) {\n      recommendations.push({\n        type: 'increase_pool_size',\n        reason: 'Pool exhaustion detected',\n        suggestion: `Increase max connections to ${stats.max * 1.5}`\n      });\n    }\n    \n    if (stats.available > stats.max * 0.8) {\n      recommendations.push({\n        type: 'decrease_pool_size',\n        reason: 'Pool underutilized',\n        suggestion: `Decrease max connections to ${Math.ceil(stats.max * 0.6)}`\n      });\n    }\n    \n    return recommendations;\n  }\n}\n```\n\n3. 자동 스케일링:\n```javascript\n// AutoScaler.js\nclass PoolAutoScaler {\n  constructor(poolManager, metricsService) {\n    this.poolManager = poolManager;\n    this.metricsService = metricsService;\n    this.scalingPolicies = new Map();\n  }\n  \n  async enableAutoScaling(systemId, policy) {\n    const scalingPolicy = {\n      minSize: policy.minSize || 2,\n      maxSize: policy.maxSize || 100,\n      targetUtilization: policy.targetUtilization || 0.7,\n      scaleUpThreshold: policy.scaleUpThreshold || 0.8,\n      scaleDownThreshold: policy.scaleDownThreshold || 0.3,\n      cooldownPeriod: policy.cooldownPeriod || 300000 // 5분\n    };\n    \n    this.scalingPolicies.set(systemId, scalingPolicy);\n    \n    // 주기적 스케일링 체크\n    setInterval(() => this.checkScaling(systemId), 60000); // 1분마다\n  }\n  \n  async checkScaling(systemId) {\n    const policy = this.scalingPolicies.get(systemId);\n    const metrics = await this.metricsService.getPoolMetrics(systemId);\n    const utilization = metrics.borrowed / metrics.max;\n    \n    if (utilization > policy.scaleUpThreshold) {\n      await this.scaleUp(systemId, policy);\n    } else if (utilization < policy.scaleDownThreshold) {\n      await this.scaleDown(systemId, policy);\n    }\n  }\n}\n```",
        "testStrategy": "1. 연결 풀 부하 테스트: Apache JMeter로 동시 연결 1000개 이상 처리\n2. 성능 벤치마크: 연결 획득 시간 < 50ms, 풀 효율성 > 80%\n3. 자동 스케일링 테스트: 부하 변화에 따른 풀 크기 조정 검증\n4. 장애 복구 테스트: 연결 실패 시 자동 재생성 및 복구\n5. 메모리 누수 테스트: 장시간 실행 시 메모리 사용량 모니터링",
        "priority": "medium",
        "dependencies": [
          28,
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "사용자 경험 개선 및 UI/UX 향상",
        "description": "실시간 폼 검증, 연결 설정 마법사, 대량 가져오기/내보내기, 고급 필터링 및 검색, 시스템 분류 및 태깅 기능을 포함한 향상된 사용자 인터페이스를 구현합니다.",
        "details": "1. React 컴포넌트 개선 (React 18.2.0 + TypeScript):\n```typescript\n// ConnectionWizard.tsx\nimport { useState } from 'react';\nimport { Stepper, Step } from '@mui/material';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\n\nconst ConnectionWizard: React.FC = () => {\n  const [activeStep, setActiveStep] = useState(0);\n  \n  const steps = [\n    { label: '데이터베이스 유형 선택', component: DatabaseTypeSelector },\n    { label: '연결 정보 입력', component: ConnectionForm },\n    { label: '고급 설정', component: AdvancedSettings },\n    { label: '연결 테스트', component: ConnectionTest },\n    { label: '완료', component: Summary }\n  ];\n  \n  const { register, handleSubmit, formState: { errors }, watch } = useForm({\n    resolver: zodResolver(connectionSchema),\n    mode: 'onChange'\n  });\n  \n  return (\n    <div className=\"connection-wizard\">\n      <Stepper activeStep={activeStep}>\n        {steps.map((step) => (\n          <Step key={step.label}>\n            <StepLabel>{step.label}</StepLabel>\n          </Step>\n        ))}\n      </Stepper>\n      \n      <div className=\"wizard-content\">\n        {React.createElement(steps[activeStep].component, {\n          register,\n          errors,\n          watch,\n          onNext: () => setActiveStep(prev => prev + 1),\n          onBack: () => setActiveStep(prev => prev - 1)\n        })}\n      </div>\n    </div>\n  );\n};\n```\n\n2. 실시간 폼 검증 (Zod v3.22.4):\n```typescript\n// schemas/connectionSchema.ts\nimport { z } from 'zod';\n\nconst connectionSchema = z.object({\n  name: z.string().min(1, '시스템 이름은 필수입니다'),\n  type: z.enum(['postgresql', 'mysql', 'oracle', 'sqlserver', 'mongodb']),\n  host: z.string().ip('유효한 IP 주소를 입력하세요'),\n  port: z.number().int().positive().max(65535),\n  database: z.string().min(1),\n  username: z.string().min(1),\n  password: z.string().min(8, '비밀번호는 최소 8자 이상이어야 합니다'),\n  ssl: z.boolean().optional(),\n  poolSize: z.number().int().min(1).max(100).optional()\n}).refine(async (data) => {\n  // 실시간 연결 가능성 체크\n  const isReachable = await checkHostReachability(data.host, data.port);\n  return isReachable;\n}, {\n  message: '호스트에 연결할 수 없습니다',\n  path: ['host']\n});\n```\n\n3. 대량 가져오기/내보내기:\n```typescript\n// BulkImportExport.tsx\nconst BulkImportExport: React.FC = () => {\n  const handleImport = async (file: File) => {\n    const reader = new FileReader();\n    reader.onload = async (e) => {\n      const content = e.target?.result as string;\n      const systems = parseImportFile(content);\n      \n      // 검증 및 미리보기\n      const validationResults = await validateSystems(systems);\n      setPreviewData({\n        valid: validationResults.valid,\n        invalid: validationResults.invalid,\n        warnings: validationResults.warnings\n      });\n    };\n    reader.readAsText(file);\n  };\n  \n  const handleExport = async (format: 'json' | 'csv' | 'yaml') => {\n    const systems = await fetchAllSystems();\n    const exportData = formatExportData(systems, format);\n    \n    const blob = new Blob([exportData], { type: getMimeType(format) });\n    const url = URL.createObjectURL(blob);\n    \n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `systems-export-${Date.now()}.${format}`;\n    a.click();\n  };\n};\n```\n\n4. 고급 필터링 및 검색 (Fuse.js v7.0.0):\n```typescript\n// AdvancedSearch.tsx\nimport Fuse from 'fuse.js';\n\nconst AdvancedSearch: React.FC = () => {\n  const [filters, setFilters] = useState({\n    type: [],\n    status: [],\n    tags: [],\n    dateRange: null\n  });\n  \n  const fuseOptions = {\n    keys: ['name', 'description', 'host', 'tags'],\n    threshold: 0.3,\n    includeScore: true\n  };\n  \n  const fuse = new Fuse(systems, fuseOptions);\n  \n  const handleSearch = (query: string) => {\n    const results = fuse.search(query);\n    const filtered = results\n      .filter(result => applyFilters(result.item, filters))\n      .map(result => ({ ...result.item, score: result.score }));\n    \n    setSearchResults(filtered);\n  };\n};\n```\n\n5. 시스템 태깅 및 분류:\n```typescript\n// TagManager.tsx\nconst TagManager: React.FC = () => {\n  const [tags, setTags] = useState<Tag[]>([]);\n  \n  const handleAddTag = (systemId: string, tag: string) => {\n    const color = generateTagColor(tag);\n    api.addSystemTag(systemId, { name: tag, color });\n  };\n  \n  const TagInput = () => (\n    <Autocomplete\n      multiple\n      options={availableTags}\n      freeSolo\n      renderTags={(value, getTagProps) =>\n        value.map((option, index) => (\n          <Chip\n            variant=\"outlined\"\n            label={option}\n            {...getTagProps({ index })}\n            style={{ backgroundColor: getTagColor(option) }}\n          />\n        ))\n      }\n    />\n  );\n};\n```",
        "testStrategy": "1. 사용성 테스트: 5명 이상의 사용자와 함께 태스크 완료 시간 측정\n2. 접근성 테스트: axe-core로 WCAG 2.1 AA 준수 확인\n3. 성능 테스트: React DevTools Profiler로 렌더링 최적화\n4. 반응형 테스트: 다양한 화면 크기에서 UI 검증\n5. E2E 테스트: Cypress로 전체 사용자 플로우 자동화 테스트",
        "priority": "medium",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "오류 처리 및 진단 도구 구현",
        "description": "포괄적인 오류 분류, 연결 문제 해결 도구, 네트워크 연결성 테스트, 데이터베이스 스키마 검사 및 연결 성능 프로파일링을 포함한 고급 진단 시스템을 구축합니다.",
        "details": "1. 오류 분류 및 처리 시스템:\n```javascript\n// ErrorClassifier.js\nclass ErrorClassifier {\n  constructor() {\n    this.errorPatterns = [\n      {\n        pattern: /ECONNREFUSED/,\n        type: 'CONNECTION_REFUSED',\n        severity: 'critical',\n        message: '데이터베이스 서버에 연결할 수 없습니다',\n        solutions: [\n          '데이터베이스 서버가 실행 중인지 확인하세요',\n          '방화벽 설정을 확인하세요',\n          '호스트 및 포트 정보가 올바른지 확인하세요'\n        ]\n      },\n      {\n        pattern: /authentication failed/i,\n        type: 'AUTH_FAILED',\n        severity: 'high',\n        message: '인증에 실패했습니다',\n        solutions: [\n          '사용자 이름과 비밀번호를 확인하세요',\n          '사용자 권한을 확인하세요',\n          '계정이 잠겨있는지 확인하세요'\n        ]\n      },\n      {\n        pattern: /SSL/i,\n        type: 'SSL_ERROR',\n        severity: 'medium',\n        message: 'SSL 연결 오류',\n        solutions: [\n          'SSL 인증서가 유효한지 확인하세요',\n          'SSL 모드 설정을 확인하세요',\n          'CA 인증서 경로를 확인하세요'\n        ]\n      }\n    ];\n  }\n  \n  classify(error) {\n    const errorString = error.toString();\n    \n    for (const pattern of this.errorPatterns) {\n      if (pattern.pattern.test(errorString)) {\n        return {\n          ...pattern,\n          originalError: error,\n          timestamp: new Date(),\n          diagnostics: this.runDiagnostics(pattern.type)\n        };\n      }\n    }\n    \n    return {\n      type: 'UNKNOWN',\n      severity: 'medium',\n      message: '알 수 없는 오류가 발생했습니다',\n      originalError: error\n    };\n  }\n}\n```\n\n2. 네트워크 진단 도구:\n```javascript\n// NetworkDiagnostics.js\nconst net = require('net');\nconst dns = require('dns').promises;\nconst ping = require('ping');\n\nclass NetworkDiagnostics {\n  async runFullDiagnostics(host, port) {\n    const results = {\n      dnsResolution: await this.checkDNS(host),\n      ping: await this.checkPing(host),\n      portOpen: await this.checkPort(host, port),\n      traceroute: await this.runTraceroute(host),\n      latency: await this.measureLatency(host, port)\n    };\n    \n    return this.generateReport(results);\n  }\n  \n  async checkPort(host, port) {\n    return new Promise((resolve) => {\n      const socket = new net.Socket();\n      socket.setTimeout(5000);\n      \n      socket.on('connect', () => {\n        socket.destroy();\n        resolve({ open: true, responseTime: Date.now() - startTime });\n      });\n      \n      socket.on('timeout', () => {\n        socket.destroy();\n        resolve({ open: false, error: 'timeout' });\n      });\n      \n      socket.on('error', (err) => {\n        resolve({ open: false, error: err.message });\n      });\n      \n      const startTime = Date.now();\n      socket.connect(port, host);\n    });\n  }\n  \n  async measureLatency(host, port, samples = 10) {\n    const measurements = [];\n    \n    for (let i = 0; i < samples; i++) {\n      const start = Date.now();\n      const result = await this.checkPort(host, port);\n      \n      if (result.open) {\n        measurements.push(Date.now() - start);\n      }\n    }\n    \n    return {\n      min: Math.min(...measurements),\n      max: Math.max(...measurements),\n      avg: measurements.reduce((a, b) => a + b, 0) / measurements.length,\n      samples: measurements\n    };\n  }\n}\n```\n\n3. 데이터베이스 스키마 검사기:\n```javascript\n// SchemaInspector.js\nclass SchemaInspector {\n  async inspectDatabase(connection, dbType) {\n    const inspector = this.getInspector(dbType);\n    return await inspector.inspect(connection);\n  }\n  \n  getInspector(dbType) {\n    const inspectors = {\n      postgresql: {\n        inspect: async (conn) => {\n          const tables = await conn.query(`\n            SELECT table_name, table_type \n            FROM information_schema.tables \n            WHERE table_schema = 'public'\n          `);\n          \n          const schemas = await conn.query(`\n            SELECT schema_name \n            FROM information_schema.schemata\n          `);\n          \n          const size = await conn.query(`\n            SELECT pg_database_size(current_database()) as size\n          `);\n          \n          return {\n            tables: tables.rows,\n            schemas: schemas.rows,\n            size: this.formatBytes(size.rows[0].size),\n            version: await this.getVersion(conn)\n          };\n        }\n      },\n      mysql: {\n        inspect: async (conn) => {\n          const [tables] = await conn.query('SHOW TABLES');\n          const [status] = await conn.query('SHOW STATUS');\n          const [variables] = await conn.query('SHOW VARIABLES');\n          \n          return {\n            tables,\n            status: this.parseStatus(status),\n            configuration: this.parseVariables(variables)\n          };\n        }\n      }\n    };\n    \n    return inspectors[dbType];\n  }\n}\n```\n\n4. 성능 프로파일러:\n```javascript\n// PerformanceProfiler.js\nclass PerformanceProfiler {\n  async profileConnection(systemId, duration = 60000) {\n    const metrics = {\n      queries: [],\n      connectionStats: [],\n      resourceUsage: []\n    };\n    \n    const startTime = Date.now();\n    const interval = setInterval(async () => {\n      // 쿼리 성능 측정\n      const queryMetric = await this.measureQueryPerformance(systemId);\n      metrics.queries.push(queryMetric);\n      \n      // 연결 통계\n      const connStats = await this.getConnectionStats(systemId);\n      metrics.connectionStats.push(connStats);\n      \n      // 리소스 사용량\n      const resources = await this.getResourceUsage(systemId);\n      metrics.resourceUsage.push(resources);\n      \n      if (Date.now() - startTime > duration) {\n        clearInterval(interval);\n      }\n    }, 1000);\n    \n    return new Promise((resolve) => {\n      setTimeout(() => {\n        clearInterval(interval);\n        resolve(this.analyzeMetrics(metrics));\n      }, duration);\n    });\n  }\n  \n  analyzeMetrics(metrics) {\n    return {\n      queryPerformance: {\n        avgResponseTime: this.calculateAverage(metrics.queries, 'responseTime'),\n        p95ResponseTime: this.calculatePercentile(metrics.queries, 'responseTime', 95),\n        throughput: metrics.queries.length / (metrics.duration / 1000)\n      },\n      connectionHealth: {\n        avgActiveConnections: this.calculateAverage(metrics.connectionStats, 'active'),\n        maxConnections: Math.max(...metrics.connectionStats.map(s => s.active)),\n        connectionChurn: this.calculateChurn(metrics.connectionStats)\n      },\n      recommendations: this.generateRecommendations(metrics)\n    };\n  }\n}\n```",
        "testStrategy": "1. 오류 시나리오 테스트: 50개 이상의 다양한 오류 케이스 시뮬레이션\n2. 진단 도구 정확성: 실제 네트워크 문제 상황에서 진단 결과 검증\n3. 성능 프로파일러 테스트: 부하 상황에서 정확한 메트릭 수집 확인\n4. 스키마 검사기 호환성: 모든 지원 데이터베이스에서 정확한 정보 추출\n5. 사용자 피드백 테스트: 오류 해결 제안의 효과성 측정",
        "priority": "low",
        "dependencies": [
          28,
          29
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "외부 시스템 통합 구현",
        "description": "LDAP/Active Directory 인증, 클라우드 데이터베이스 자동 검색, 구성 관리 도구 통합 및 모니터링 시스템(Prometheus, Grafana) 연동을 구현합니다.",
        "details": "1. LDAP/AD 통합 (ldapjs v3.0.0):\n```javascript\n// LDAPIntegration.js\nconst ldap = require('ldapjs');\n\nclass LDAPIntegration {\n  constructor(config) {\n    this.client = ldap.createClient({\n      url: config.url,\n      bindDN: config.bindDN,\n      bindCredentials: config.bindPassword,\n      searchBase: config.searchBase,\n      searchFilter: config.searchFilter || '(objectClass=user)',\n      reconnect: true\n    });\n  }\n  \n  async authenticateUser(username, password) {\n    return new Promise((resolve, reject) => {\n      // 사용자 검색\n      const searchOptions = {\n        filter: `(sAMAccountName=${username})`,\n        scope: 'sub',\n        attributes: ['dn', 'mail', 'memberOf']\n      };\n      \n      this.client.search(this.config.searchBase, searchOptions, (err, res) => {\n        if (err) return reject(err);\n        \n        let userDN = null;\n        res.on('searchEntry', (entry) => {\n          userDN = entry.objectName;\n        });\n        \n        res.on('end', () => {\n          if (!userDN) return resolve({ success: false });\n          \n          // 사용자 인증\n          const userClient = ldap.createClient({ url: this.config.url });\n          userClient.bind(userDN, password, (err) => {\n            userClient.unbind();\n            resolve({ success: !err, userDN, error: err });\n          });\n        });\n      });\n    });\n  }\n  \n  async getDatabaseCredentials(username) {\n    // AD에서 데이터베이스 자격 증명 매핑 조회\n    const user = await this.searchUser(username);\n    const dbCredentials = {};\n    \n    // 그룹 멤버십 기반 권한 매핑\n    for (const group of user.memberOf) {\n      if (group.includes('CN=DB_PostgreSQL_Admin')) {\n        dbCredentials.postgresql = {\n          username: user.sAMAccountName,\n          role: 'admin'\n        };\n      }\n    }\n    \n    return dbCredentials;\n  }\n}\n```\n\n2. 클라우드 데이터베이스 자동 검색:\n```javascript\n// CloudDiscovery.js\nclass CloudDatabaseDiscovery {\n  constructor() {\n    this.providers = {\n      aws: new AWSDiscovery(),\n      azure: new AzureDiscovery(),\n      gcp: new GCPDiscovery()\n    };\n  }\n  \n  async discoverAllDatabases() {\n    const discoveries = await Promise.all([\n      this.providers.aws.discover(),\n      this.providers.azure.discover(),\n      this.providers.gcp.discover()\n    ]);\n    \n    return this.normalizeDiscoveries(discoveries.flat());\n  }\n}\n\n// AWS RDS Discovery\nclass AWSDiscovery {\n  async discover() {\n    const AWS = require('aws-sdk');\n    const rds = new AWS.RDS();\n    const redshift = new AWS.Redshift();\n    \n    const [rdsInstances, redshiftClusters] = await Promise.all([\n      rds.describeDBInstances().promise(),\n      redshift.describeClusters().promise()\n    ]);\n    \n    return [\n      ...rdsInstances.DBInstances.map(db => ({\n        provider: 'aws',\n        service: 'rds',\n        id: db.DBInstanceIdentifier,\n        engine: db.Engine,\n        version: db.EngineVersion,\n        endpoint: {\n          host: db.Endpoint.Address,\n          port: db.Endpoint.Port\n        },\n        status: db.DBInstanceStatus,\n        size: db.DBInstanceClass,\n        storage: db.AllocatedStorage,\n        multiAZ: db.MultiAZ,\n        tags: db.TagList\n      })),\n      ...redshiftClusters.Clusters.map(cluster => ({\n        provider: 'aws',\n        service: 'redshift',\n        id: cluster.ClusterIdentifier,\n        engine: 'redshift',\n        endpoint: {\n          host: cluster.Endpoint.Address,\n          port: cluster.Endpoint.Port\n        },\n        status: cluster.ClusterStatus,\n        nodeType: cluster.NodeType,\n        numberOfNodes: cluster.NumberOfNodes\n      }))\n    ];\n  }\n}\n```\n\n3. Prometheus 메트릭 익스포터:\n```javascript\n// PrometheusExporter.js\nconst promClient = require('prom-client');\n\nclass PrometheusExporter {\n  constructor() {\n    this.register = new promClient.Registry();\n    \n    // 커스텀 메트릭 정의\n    this.metrics = {\n      connectionStatus: new promClient.Gauge({\n        name: 'nificdc_connection_status',\n        help: 'Database connection status (1=up, 0=down)',\n        labelNames: ['system_id', 'system_name', 'db_type']\n      }),\n      \n      connectionLatency: new promClient.Histogram({\n        name: 'nificdc_connection_latency_ms',\n        help: 'Database connection latency in milliseconds',\n        labelNames: ['system_id', 'system_name', 'db_type'],\n        buckets: [10, 50, 100, 500, 1000, 5000]\n      }),\n      \n      poolUtilization: new promClient.Gauge({\n        name: 'nificdc_pool_utilization',\n        help: 'Connection pool utilization percentage',\n        labelNames: ['system_id', 'system_name']\n      }),\n      \n      errorRate: new promClient.Counter({\n        name: 'nificdc_connection_errors_total',\n        help: 'Total number of connection errors',\n        labelNames: ['system_id', 'system_name', 'error_type']\n      })\n    };\n    \n    // 메트릭 등록\n    Object.values(this.metrics).forEach(metric => {\n      this.register.registerMetric(metric);\n    });\n  }\n  \n  updateMetrics(systemId, metrics) {\n    const labels = {\n      system_id: systemId,\n      system_name: metrics.name,\n      db_type: metrics.type\n    };\n    \n    this.metrics.connectionStatus.set(labels, metrics.isConnected ? 1 : 0);\n    this.metrics.connectionLatency.observe(labels, metrics.latency);\n    this.metrics.poolUtilization.set(\n      { system_id: systemId, system_name: metrics.name },\n      metrics.poolUtilization\n    );\n  }\n  \n  getMetrics() {\n    return this.register.metrics();\n  }\n}\n```\n\n4. Grafana 대시보드 프로비저닝:\n```javascript\n// GrafanaProvisioner.js\nclass GrafanaProvisioner {\n  async provisionDashboard() {\n    const dashboard = {\n      dashboard: {\n        title: 'NiFiCDC System Management',\n        panels: [\n          {\n            title: 'Connection Status Overview',\n            type: 'stat',\n            targets: [{\n              expr: 'sum(nificdc_connection_status) by (db_type)'\n            }]\n          },\n          {\n            title: 'Connection Latency',\n            type: 'graph',\n            targets: [{\n              expr: 'histogram_quantile(0.95, nificdc_connection_latency_ms)'\n            }]\n          },\n          {\n            title: 'Error Rate',\n            type: 'graph',\n            targets: [{\n              expr: 'rate(nificdc_connection_errors_total[5m])'\n            }]\n          }\n        ]\n      }\n    };\n    \n    await this.grafanaAPI.createDashboard(dashboard);\n  }\n}\n```\n\n5. 구성 관리 통합 (Ansible/Terraform):\n```javascript\n// ConfigManagement.js\nclass ConfigManagementIntegration {\n  async exportToAnsible(systems) {\n    const inventory = {\n      all: {\n        children: {\n          databases: {\n            hosts: {}\n          }\n        }\n      }\n    };\n    \n    systems.forEach(system => {\n      inventory.all.children.databases.hosts[system.name] = {\n        ansible_host: system.host,\n        ansible_port: system.port,\n        db_type: system.type,\n        db_name: system.database\n      };\n    });\n    \n    return yaml.dump(inventory);\n  }\n  \n  async exportToTerraform(systems) {\n    const resources = systems.map(system => ({\n      [`database_${system.name}`]: {\n        type: this.mapToTerraformResource(system.type),\n        properties: {\n          name: system.name,\n          host: system.host,\n          port: system.port,\n          database: system.database\n        }\n      }\n    }));\n    \n    return this.generateTerraformConfig(resources);\n  }\n}\n```",
        "testStrategy": "1. LDAP 통합 테스트: 실제 AD 환경 또는 OpenLDAP 테스트 서버 사용\n2. 클라우드 검색 테스트: LocalStack으로 AWS 서비스 모의\n3. Prometheus 메트릭 검증: 메트릭 정확성 및 성능 영향 측정\n4. Grafana 대시보드 테스트: 자동 프로비저닝 및 시각화 검증\n5. 구성 관리 통합 테스트: Ansible/Terraform 구성 파일 유효성 검증",
        "priority": "low",
        "dependencies": [
          30,
          31
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-11T19:04:31.110Z",
      "updated": "2025-07-14T06:58:56.244Z",
      "description": "Tasks for master context"
    }
  }
}